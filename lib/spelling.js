// Generated by CoffeeScript 1.9.0
(function() {
  var ALPHABET, R, exports, find_edits1_of, find_edits2_of, get_deletes, get_inserts, get_replacements, get_transpositions, spell;

  R = require('ramda');

  ALPHABET = "abcdefghijklmnopqrstuvwxyz";

  get_deletes = function(splits) {
    return splits.map(function(elem) {
      return elem[0] + elem[1].slice(1);
    });
  };

  get_inserts = function(splits) {
    var inserts, letter, _i, _len;
    inserts = [];
    for (_i = 0, _len = ALPHABET.length; _i < _len; _i++) {
      letter = ALPHABET[_i];
      splits.forEach(function(elem) {
        return inserts.push(elem[0] + letter + elem[1]);
      });
    }
    return inserts;
  };

  get_replacements = function(splits) {
    var letter, replacements, _i, _len;
    replacements = [];
    for (_i = 0, _len = ALPHABET.length; _i < _len; _i++) {
      letter = ALPHABET[_i];
      splits.forEach(function(elem) {
        if (elem[1]) {
          return replacements.push(elem[0] + letter + elem[1].slice(1));
        }
      });
    }
    return replacements;
  };

  get_transpositions = function(splits) {
    return splits.filter(function(e) {
      return e[1].length > 1;
    }).map(function(e) {
      return e[0] + e[1][1] + e[1][0] + e[1].slice(2);
    });
  };


  /*
    FUNCTION: find_edits1_of( word )
    Finds all strings one edit distance away from input word
    @param {String} word - input word
    @returns {Array} result set - strings one edit distance away from input word
   */

  find_edits1_of = function(word) {
    var i, makeSet, splits, _i, _len, _ref;
    splits = [];
    _ref = R.range(0, word.length + 1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      splits.push([word.slice(0, i), word.slice(i)]);
    }
    makeSet = R.compose(R.uniq, R.concat);
    return makeSet(get_deletes(splits), get_inserts(splits), get_replacements(splits), get_transpositions(splits));
  };


  /*
   FUNCTION: find_edits2_of( word )
   Finds all strings two edit distances away from word
   @param {String} word - input word
   @returns {Array} result set - strings two edit distances away from input word
   */

  find_edits2_of = function(word) {
    return R.pipe(find_edits1_of, R.map(function(w) {
      return find_edits1_of(w);
    }), R.flatten, R.uniq)(word);
  };


  /*
   FUNCTION: spell( word )
   Finds possible correction for input word
   @param {String} word - input word
   @returns {String} the suggested correction
   */

  spell = function(word) {};

  module.exports = exports = {
    "spell": spell,
    "find_edits1_of": find_edits1_of,
    "find_edits2_of": find_edits2_of
  };

}).call(this);
