// Generated by CoffeeScript 1.9.0
(function() {
  var ALPHABET, BPromise, R, bluebird, db, db_path, exports, fetch_unigram_data, find_edits1_of, find_edits2_of, get_deletes, get_inserts, get_replacements, get_top_term, get_transpositions, path, spell, sqlite3;

  R = require('ramda');

  sqlite3 = require('sqlite3');

  bluebird = require('bluebird');

  BPromise = bluebird.Promise;

  path = require('path');

  db_path = path.normalize(__dirname + '/../data/unigrams.sqlite');

  db = new sqlite3.Database(db_path);

  db = BPromise.promisifyAll(db);

  ALPHABET = "abcdefghijklmnopqrstuvwxyz";

  get_deletes = function(splits) {
    var deletes;
    deletes = splits.map(function(elem) {
      return elem[0] + elem[1].slice(1);
    });
    return deletes;
  };

  get_inserts = function(splits) {
    var inserts, letter, _i, _len;
    inserts = [];
    for (_i = 0, _len = ALPHABET.length; _i < _len; _i++) {
      letter = ALPHABET[_i];
      splits.forEach(function(elem) {
        return inserts.push(elem[0] + letter + elem[1]);
      });
    }
    return inserts;
  };

  get_replacements = function(splits) {
    var letter, replacements, _i, _len;
    replacements = [];
    for (_i = 0, _len = ALPHABET.length; _i < _len; _i++) {
      letter = ALPHABET[_i];
      splits.forEach(function(elem) {
        if (elem[1]) {
          return replacements.push(elem[0] + letter + elem[1].slice(1));
        }
      });
    }
    return replacements;
  };

  get_transpositions = function(splits) {
    var transpositions;
    transpositions = splits.filter(function(e) {
      return e[1].length > 1;
    }).map(function(e) {
      return e[0] + e[1][1] + e[1][0] + e[1].slice(2);
    });
    return transpositions;
  };


  /*
    FUNCTION: find_edits1_of( word )
    Finds all strings one edit distance away from input word
    @param {String} word - input word
    @returns {Array} result set - strings one edit distance away from input word
   */

  find_edits1_of = function(word) {
    var candidates, deletes, i, inserts, replacements, resultSet, splits, transpositions, _i, _len, _ref;
    splits = [];
    _ref = R.range(0, word.length + 1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      splits.push([word.slice(0, i), word.slice(i)]);
    }
    deletes = get_deletes(splits);
    inserts = get_inserts(splits);
    replacements = get_replacements(splits);
    transpositions = get_transpositions(splits);
    candidates = [].concat(deletes).concat(inserts).concat(replacements).concat(transpositions);
    resultSet = R.uniq(candidates);
    return resultSet;
  };


  /*
   FUNCTION: find_edits2_of( word )
   Finds all strings two edit distances away from word
   @param {String} word - input word
   @returns {Array} result set - strings two edit distances away from input word
   */

  find_edits2_of = function(word) {
    return R.pipe(find_edits1_of, R.map(function(w) {
      return find_edits1_of(w);
    }), R.flatten, R.uniq)(word);
  };

  fetch_unigram_data = function(terms) {
    var query;
    terms = terms.map(function(e) {
      return "'" + e + "'";
    });
    query = "SELECT term, freq FROM unigrams WHERE term IN ( " + (terms.join(',')) + " )";
    return db.allAsync(query);
  };

  get_top_term = function(arr) {
    return R.compose(R.prop("term"), R.maxBy(function(obj) {
      return obj.freq;
    }))(arr);
  };


  /*
   FUNCTION: spell( word )
   Finds possible correction for input word
   @param {String} word - input word
   @returns {String} the suggested correction
   */

  spell = function(input, callback) {
    var fword, suggestion;
    fword = fetch_unigram_data(R.of(input));
    suggestion = fword.then(function(word) {
      var fEdits1;
      if (word && word.length > 0) {
        return get_top_term(word);
      } else {
        fEdits1 = fetch_unigram_data(find_edits1_of(input));
        return fEdits1.then(function(edits1) {
          var fEdits2;
          if (edits1 && edits1.length > 0) {
            return get_top_term(edits1);
          } else {
            fEdits2 = fetch_unigram_data(find_edits2_of(input));
            return fEdits2.then(function(edits2) {
              if (edits2 && edits2.length > 0) {
                return get_top_term(edits2);
              } else {
                return input;
              }
            });
          }
        });
      }
    });
    return suggestion.nodeify(callback);
  };

  module.exports = exports = {
    "spell": spell,
    "find_edits1_of": find_edits1_of,
    "find_edits2_of": find_edits2_of,
    "fetch_unigram_data": fetch_unigram_data
  };

  spell("langauge").then(function(res) {
    return console.log(res);
  });

}).call(this);
